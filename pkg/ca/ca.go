//go:generate go tool go-enum --lower --names
package ca

import (
	"crypto/x509"
	"crypto/x509/pkix"
	"errors"
	"fmt"
	"github.com/chigopher/pathlib"
	"github.com/spf13/afero"
	"github.com/wrouesnel/certutils"
	"github.com/wrouesnel/makecerts/pkg/models"
	"github.com/wrouesnel/makecerts/pkg/storage"
	"github.com/wrouesnel/makecerts/pkg/util"
	"go.uber.org/zap"
	"strings"
	"time"
)

var (
	ErrCADoesNotExist = errors.New("existing CA does not exist")
	ErrCSRRequested   = errors.New("CA CSR requested")
)

// ENUM(existing,generate,generate-csr)
type CaMode string

type CaConfig struct {
	CommonName         string        `help:"CA Certificate Common Name, as in 'example.com'" default:"localhost"`
	Country            string        `help:"Certificate attribute: Country" default:"US"`
	Organization       string        `help:"Certificate attribute: Organization" default:"makecerts"`
	OrganizationalUnit string        `help:"Certificate attribute: Organizational Unit" default:"Root CA"`
	Duration           time.Duration `help:"Duration in days that CA certificate is valid for" default:"175199h"`
}

func SubjectFromCaConfig(caConfig CaConfig) pkix.Name {
	return pkix.Name{
		Country:            []string{caConfig.Country},
		Organization:       []string{caConfig.Organization},
		OrganizationalUnit: []string{caConfig.OrganizationalUnit},
		CommonName:         caConfig.CommonName,
	}
}

// HandleCACertificate manages the CA certificate configuration for the run, and either
// returns the certificate and key, _or_ returns an error if execution should not proceed.
// Notably ErrCSRRequested is returned if CA certificate generation required a signed CSR
// (in which case although we generated a key, execution can't continue).
func HandleCACertificate(fs afero.Fs, filenameConfig models.CertificateFilenameConfig, caConfig CaConfig, mode CaMode, keyType certutils.PrivateKeyType) (*models.X509CertificateAndKey, error) {
	l := zap.L()

	certFilenameBuilder := []string{}
	certFilenameBuilder = util.AppendIfNotBlank(certFilenameBuilder, filenameConfig.CaPrefix)
	certFilenameBuilder = util.AppendIfNotBlank(certFilenameBuilder, filenameConfig.NamePrefix)
	certFilenameBuilder = util.AppendIfNotBlank(certFilenameBuilder, certutils.CommonNameToFileName(caConfig.CommonName))
	certFilenameBuilder = util.AppendIfNotBlank(certFilenameBuilder, filenameConfig.NameSuffix)
	certFilenameBuilder = util.AppendIfNotBlank(certFilenameBuilder, filenameConfig.CaSuffix)

	certBasename := strings.Join(certFilenameBuilder, ".")

	certFilename := filenameConfig.CACertName
	keyFilename := filenameConfig.CAKeyName
	reqFilename := filenameConfig.CACSRName

	if certFilename == "" {
		certFilename = fmt.Sprintf("%s.%s", certBasename, filenameConfig.CertFileExt)
	}

	if keyFilename == "" {
		keyFilename = fmt.Sprintf("%s.%s", certBasename, filenameConfig.KeyFileExt)
	}

	if reqFilename != "" {
		reqFilename = fmt.Sprintf("%s.%s", certBasename, filenameConfig.RequestFileExt)
	}

	certPath := pathlib.NewPath(certFilename, pathlib.PathWithAfero(fs))
	keyPath := pathlib.NewPath(keyFilename, pathlib.PathWithAfero(fs))
	reqPath := pathlib.NewPath(reqFilename, pathlib.PathWithAfero(fs))

	l = l.With(zap.String("cert", certFilename), zap.String("key", keyFilename))

	if ca, err := loadExistingCA(certPath, keyPath); err != nil {
		l.Debug("Existing CA does not exist")
		if mode == CaModeExisting {
			return nil, errors.Join(ErrCADoesNotExist, err)
		}
	} else {
		return ca, nil
	}

	l.Info("No existing Certificate Authority key - generating a new one")
	privateKey, err := storage.GenerateOrLoadPrivateKey(keyType, keyPath)
	if err != nil {
		l.Error("Error generating new private key", zap.Error(err))
		return nil, err
	}

	// Certificate authority is either generated by self-signing our own CSR,
	// or emitting the CSR and quitting till the certificate file exists.
	csr, err := certutils.GenerateCSR(SubjectFromCaConfig(caConfig), certutils.CSRParameters{
		KeyUsage: x509.KeyUsageCRLSign | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
		IsCA:     true,
	}, privateKey)
	if err != nil {
		l.Error("Error generating CSR", zap.Error(err))
		return nil, err
	}

	if mode == CaModeGenerateCsr {
		l.Info("Generating CSR for new Certificate Authority")
		csrBytes, err := certutils.EncodeRequest(csr)
		if err != nil {
			l.Error("Error encoding CSR request", zap.Error(err))
			return nil, err
		}
		if err := reqPath.WriteFile(csrBytes); err != nil {
			l.Error("Error writing CSR", zap.Error(err))
			return nil, err
		}
		// Return an error since the CSR will need to be signed.
		return nil, ErrCSRRequested
	}

	l.Info("Generating a new standalone Certificate Authority")
	cert, err := certutils.SignCertificate(csr, nil, privateKey, certutils.SigningParameters{
		SerialNumber: time.Now().UnixNano(),
		NotBefore:    certutils.CertificateNotBefore(),
		NotAfter:     certutils.CACertificateNotAfter(caConfig.Duration),
	})
	if err != nil {
		l.Error("Error signing new CA certificate", zap.Error(err))
		return nil, err
	}

	encodedCaCert, err := certutils.EncodeCertificates(cert)
	if err != nil {
		l.Error("Error encoding certificate", zap.Error(err))
		return nil, err
	}

	if err := certPath.WriteFile(encodedCaCert); err != nil {
		l.Error("Error encoding certificate", zap.Error(err))
		return nil, err
	}

	return &models.X509CertificateAndKey{
		Cert: cert,
		Key:  privateKey,
	}, nil
}

func loadExistingCA(certPath *pathlib.Path, keyPath *pathlib.Path) (*models.X509CertificateAndKey, error) {
	l := zap.L()
	l.Debug("Attempting to load existing CA",
		zap.String("cert", certPath.String()), zap.String("key", keyPath.String()))

	// since these are afero paths, they could be anywhere - we need to copy them to real paths and load them from there.
	certificatePair, err := certutils.LoadX509KeyPair(certPath.Fs(), certPath.String(), keyPath.String())
	if err != nil {
		return nil, errors.Join(fmt.Errorf("could not load CA certificate from: %s and %s", certPath.String(), keyPath.String()))
	}
	caCertificate, err := x509.ParseCertificate(certificatePair.Certificate[0])
	if err != nil {
		return nil, err
	}
	return &models.X509CertificateAndKey{
		Cert: caCertificate,
		Key:  certificatePair.PrivateKey,
	}, nil
}
